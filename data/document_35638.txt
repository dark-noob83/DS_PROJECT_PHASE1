The following code example demonstrates that the nullptr keyword can be used wherever a handle, native pointer, or function argument can be used. And the example demonstrates that the nullptr keyword can be used to check a reference before it is used. Use nullptr with either managed or native code. The compiler emits appropriate but different instructions for managed and native null pointer values. For information about using the ISO standard C++ version of this keyword, see nullptr.
Still, I am not getting how nullptr works. For example, Wikipedia article says: C++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant: nullptr. It is of type nullptr_t, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool. We now have C++11 with many new features. An interesting and confusing one (at least for me) is the new nullptr. 4.10 about pointer conversion says that a prvalue of type std::nullptr_t is a null pointer constant, and that an integral null pointer constant can be converted to std::nullptr_t. The opposite direction is not allowed.
C++11 adds a null pointer constant called nullptr. The use of nullptr should be preferred over 0 or NULL. GCC just added a warning for the use of 0 as a pointer, so they are strongly encouraging you to use nullptr. For the operators and, two values of type std::nullptr_t shall compare as true. Comparing with or gives false. Comparing anything else with a value of type std::nullptr_t is unspecified. Comparing anything using != or == with nullptr gives true or false if it is not null or null respectively.
Type of the null pointer constant nullptr. This type can only take one value: nullptr, which when converted to a pointer type takes the proper null pointer value.
std::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type. If two or more overloads accept different pointer types, an overload for std::nullptr_t is necessary to accept a null pointer argument.
Designates a null pointer constant of type std::nullptr_t, which is convertible to any raw pointer type. Although you can use the keyword nullptr without including any headers, if your code uses the type std::nullptr_t, then you must define it by including the header. 
The __nullptr keyword is a Microsoft-specific keyword that has the same meaning as nullptr, but applies to only native code. If you use nullptr with native C/C++ code and then compile with the /clr compiler option, the compiler cannot determine whether nullptr indicates a native or managed null pointer value. Use nullptr with either managed or native code. The compiler emits appropriate but different instructions for managed and native null pointer values. For information about using the ISO standard C++ version of this keyword, see nullptr.
[edit] Explanation. The keyword nullptr denotes the pointer literal. It is a prvalue of type std::nullptr_t. There exist implicit conversions from nullptr to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type std::nullptr_t as well as the macro NULL.