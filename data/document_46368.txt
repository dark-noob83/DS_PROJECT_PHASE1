Here is a multiple element Java annotation example: In case an annotation contains just a single element, it is convention to name that element value, like this: When an annotation just contains a single element named value, you can leave out the element name, and just provide the value. Annotation Elements. A Java annotation can have elements for which you can set values. An element is like an attribute or parameter. Here is an example of a Java annotation with an element: The annotation in this example contains a single element named tableName, with the value set to vehicles.
RetentionPolicy.SOURCE means that the annotation is only available in the source code, and not in the .class files and not a runtime. If you create your own annotations for use with build tools that scan the code, you can use this retention policy. That way the .class files are not polluted unnecessarily. Annotation Elements. A Java annotation can have elements for which you can set values. An element is like an attribute or parameter. Here is an example of a Java annotation with an element: The annotation in this example contains a single element named tableName, with the value set to vehicles.
[p.s. edit]. I used the String simply for demonstration and in view of an open ended meta annotation. For your own given project, you obviously can use an enum of category types and specify multiple categories (multiple inheritance) to a given annotation. Annotations are interfaces, so polymorphism doesn't really come into play, and since they are static in nature, there can be no runtime dynamic dispatching. In your validator example, you could just on the annotation get the annotated type and see if it has a validator meta-
Java Inheritance Basics. When a class inherits from a superclass, it inherits parts of the superclass methods and fields. The subclass can also override (redefine) the inherited methods. Fields cannot be overridden, but can be shadowed in subclasses. How all this works is covered later in this text.
An annotation, in the Java computer programming language, is a form of syntactic metadata that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Unlike Javadoc tags, Java annotations can be reflective in that they can be embedded in class files generated by the compiler and may be retained by the Java VM to be made retrievable at run-time. It is possible to create meta-annotations out of the existing ones in Java.
1 - Marks another annotation to be inherited to subclasses of annotated class (by default annotations are not inherited to subclasses). - 2  Specifies that the annotation can be applied more than once to the same declaration, since Java 8. Unlike Javadoc tags, Java annotations can be reflective in that they can be embedded in class files generated by the compiler and may be retained by the Java VM to be made retrievable at run-time. It is possible to create meta-annotations out of the existing ones in Java.
Try this: As you can see, you can easily group and categorize annotations without undue pain using the provided facilities. So, KISS is the reason for not introducing a meta-type type system to the Java language. Annotations are interfaces, so polymorphism doesn't really come into play, and since they are static in nature, there can be no runtime dynamic dispatching. In your validator example, you could just on the annotation get the annotated type and see if it has a validator meta-annotation.
One class can extend another class and thereby inherit from that class. When one class inherits from another class in Java, the two classes take on certain roles. The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass. When a class inherits from a superclass, it inherits parts of the superclass methods and fields. The subclass can also override (redefine) the inherited methods. Fields cannot be overridden, but can be shadowed in subclasses. How all this works is covered later in this text.
JPA defines several inheritance mechanisms, mainly defined though the @Inheritance annotation or the element. There are three inheritance strategies defined from the InheritanceType enum, SINGLE_TABLE, TABLE_PER_CLASS and JOINED. Inheritance is a fundamental concept of object-oriented programming and Java. Relational databases have no concept of inheritance, so persisting inheritance in a database can be tricky.
An important capability of the Java Persistence API is its support for inheritance and polymorphism, something that was not available in EJB 2.1. You can map a hierarchy of entities, where one entity subclasses another, to a relational database structure, and submit queries against the base class. The EJB 3.0 example illustrates inheritance from an entity. However inheritance from POJOs that are not entities -- for behavior and mapping attributes -- is also allowed. The base entity or nonentity can either be abstract or concrete.