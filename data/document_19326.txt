Read Uncommitted. This is the lowest isolation level there is. Read uncommitted causes no shared locks to be requested which allows you to read data that is currently being modified in other transactions. It also allows other transactions to modify data that you are reading.
[ See the index for the whole series ]. Read uncommitted is the weakest of the four transaction isolation levels defined in the SQL Standard (and of the six implemented in SQL Server). It allows all three so-called  concurrency phenomena , dirty reads, non-repeatable reads, and phantoms: Having introduced read uncommitted isolation as the weakest of the available isolation levels, you should be expecting it to offer even lower isolation guarantees than locking read committed (the next highest isolation level).
Read uncommitted is the weakest of the four transaction isolation levels defined in the SQL Standard (and of the six implemented in SQL Server). Having introduced read uncommitted isolation as the weakest of the available isolation levels, you should be expecting it to offer even lower isolation guarantees than locking read committed (the next highest isolation level).
With the best will in the world, there is just no better way to make SQL Server code look decidedly amateurish. If you legitimately need read uncommitted isolation for a query, code block or module, it is probably better to set the session isolation level appropriately, and supply comments to justify the action. Having introduced read uncommitted isolation as the weakest of the available isolation levels, you should be expecting it to offer even lower isolation guarantees than locking read committed (the next highest isolation level).
The lowest isolation level, read uncommitted, can retrieve data that has been modified but not committed by other transactions. All concurrency side effects can happen in read uncommitted, but there is no read locking or versioning, so overhead is minimized. Retrieve the committed version of the row that existed at the time the statement or transaction started. Read the uncommitted data modification. Choosing a transaction isolation level does not affect the locks that are acquired to protect data modifications.
The only difference between the two is that the read-uncommitted isolation level determines the locking mechanism for the entire connection and the nolock table hint determines the locking mechanism for the table that you give the hint to. As stated in the above sections, the primary benefit of using the read-uncommitted isolation level or the nolock table hint is that this reduces blocking. Users are able to use these two options and not run the risk of being blocked by readers and writers within the database.
Nevertheless, it is the default isolation level for many database engines, including SQL Server. This post in a series about isolation levels and the ACID properties of transactions looks at the logical and physical guarantees actually provided by read committed isolation. In addition to that, for several popular products, read committed isolation is the lowest isolation level available; their implementations of read uncommitted isolation are exactly the same as read committed.
In SQL Server, you can also minimize locking contention while protecting transactions from dirty reads of uncommitted data modifications using either: The READ COMMITTED isolation level with the READ_COMMITTED_SNAPSHOT database option set to ON. The SNAPSHOT isolation level. When the READ_COMMITTED_SNAPSHOT database option is ON, you can use the READCOMMITTEDLOCK table hint to request shared locking instead of row versioning for individual statements in transactions running at the READ COMMITTED
Isolation levels are described in terms of which concurrency side-effects, such as dirty reads or phantom reads, are allowed. Applies to: SQL Server 2008 R2 and higher versions. Transaction isolation levels control: Whether locks are taken when data is read, and what type of locks are requested. Database Engine Isolation Levels. The ISO standard defines the following isolation levels, all of which are supported by the SQL Server Database Engine: Read uncommitted (the lowest level where transactions are isolated only enough to ensure that physically corrupt data is not read).
This isolation level allows dirty reads. One transaction may see uncommitted changes made by some other transaction. To maintain the highest level of isolation, a DBMS usually acquires locks on data, which may result in a loss of concurrency and a high locking overhead. This isolation level relaxes this property. You may want to check out the Wikipedia article on READ UNCOMMITTED for a few examples and further reading. One alternative to the READ UNCOMMITTED level that you may want to consider is the READ COMMITTED SNAPSHOT. Quoting Jeff again: Snapshots rely on an entirely new data change tracking method ...